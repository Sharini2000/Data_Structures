for j = 1 to A.length
key = A[j]
// Insert A[j] into teh sorted subarray - A[0,...j-1]
i = j-1
while i > 0 and A[i]>key
    A[i+1] = A[i]
    i = i-1
A[i+1] = key


=====

Interview-Ready Answer
â€œInsertion Sort is a simple comparison-based sorting algorithm that builds the final sorted array one element at a time. Itâ€™s similar to how we sort playing cards in our hand â€” we take one card at a time and insert it into the correct position among the cards that are already sorted.â€

ðŸ” How it works (Step-by-step):
Start from the second element (index 1), assuming the first element is already sorted.
We put the second element in a variable called key.
Compare the current element with elements before it.
Shift all larger elements one position to the right.
Insert the current element into its correct position.
Repeat this process for all elements in the array.

## ðŸ§  **Insertion Sort â€“ Algorithm Notes**

### ðŸ”„ **How It Works**

* Insertion Sort builds the **final sorted array one item at a time**.
* It takes each element and inserts it into its **correct position** relative to the already sorted part of the array (like sorting playing cards in hand).
* **In-place sorting algorithm** (no extra array used).

### ðŸ“œ **Pseudocode**

```python
for i in range(1, len(arr)):
    key = arr[i]
    j = i - 1
    while j >= 0 and arr[j] > key:
        arr[j + 1] = arr[j]
        j -= 1
    arr[j + 1] = key
```

---

## â±ï¸ **Time Complexity**

| Case         | Time Complexity | Explanation          |
| ------------ | --------------- | -------------------- |
| Best Case    | O(n)            | Already sorted array |
| Average Case | O(nÂ²)           | Random order         |
| Worst Case   | O(nÂ²)           | Reverse sorted array |

> Comparisons + shifts dominate the time complexity.

---

## ðŸ§® **Space Complexity**

* **O(1)** â€“ constant space (in-place sorting, no additional arrays used).

---

## âœ… **Advantages**

* **Simple to implement**
* **Efficient for small datasets** (typically n < 30)
* **Stable Sort** (doesn't change the relative order of equal elements)
* **In-place** (no extra memory)
* **Adaptive**: Takes advantage of existing sorted portions
* Useful in **online sorting** (can sort as elements come in one at a time)

---

## âŒ **Disadvantages**

* **Not efficient for large datasets** (O(nÂ²) time)
* Poor performance compared to advanced algorithms like Merge Sort, Quick Sort, or TimSort
* Too slow for performance-critical applications on large lists

---

## ðŸŽ¯ **Use Cases / Applications**

* Small input sizes where overhead of more complex sorts isn't justified
* Arrays that are **almost sorted** (Insertion Sort is adaptive and performs better)
* **Online algorithms** where data is received and sorted in real-time
* Embedded systems or microcontrollers (due to low space usage)
* As part of **hybrid algorithms** (e.g., Python's TimSort uses Insertion Sort for small subarrays)

---

## ðŸ“Š Comparison with Other Sorting Algorithms

| Feature      | Insertion Sort | Merge Sort | Quick Sort | Bubble Sort |
| ------------ | -------------- | ---------- | ---------- | ----------- |
| Time (Best)  | O(n)           | O(n log n) | O(n log n) | O(n)        |
| Time (Worst) | O(nÂ²)          | O(n log n) | O(nÂ²)      | O(nÂ²)       |
| Space        | O(1)           | O(n)       | O(log n)   | O(1)        |
| Stability    | Yes            | Yes        | No         | Yes         |
| In-place     | Yes            | No         | Yes        | Yes         |

---

## ðŸ§ª Example

```python
arr = [4, 3, 2, 10, 12]
# Sorted step-by-step:
# i = 1 -> [3, 4, 2, 10, 12]
# i = 2 -> [2, 3, 4, 10, 12]
# i = 3 -> [2, 3, 4, 10, 12]
# i = 4 -> [2, 3, 4, 10, 12] (already in place)
```

---

Let me know if you want this summarized into a **cheat-sheet style**, **diagram**, or **PDF**, or if you want practice problems too.
